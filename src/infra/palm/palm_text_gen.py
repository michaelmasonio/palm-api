from typing import Dict, List
import google.generativeai as palm
from google.api_core import retry

from infra.palm import palm_config as palm_config
from infra.palm import palm_embed as palm_embed

cfg = palm_config.load_config()
api_key = cfg["api_key"]

palm.configure(api_key=api_key)


@retry.Retry()
def generate_text(*args, **kwargs):
    """
    Generate the text using the palm generator.

    Args:
        *args: Variable length argument list.
        **kwargs: Arbitrary keyword arguments.

    Returns:
        The generated text.

    Raises:
        None.
    """
    return palm.generate_text(*args, **kwargs)


def generate_candidates(prompt: str) -> str:
    """
    Generates a list of candidate completions for a given prompt.

    Args:
        prompt (str): The input prompt for generating completions.

    Returns:
        str: The completion generated by the model.
    """
    models = [
        m
        for m in palm.list_models()
        if "generateText" in m.supported_generation_methods
    ]
    model = models[0].name

    completion = palm.generate_text(
        model=model,
        prompt=prompt,
        temperature=1,
        max_output_tokens=800,
        candidate_count=8,
    )

    return completion


def generate_close_to(question: str) -> str:
    """
    Generates a close-to statement for embeddings based on a provided question.

    :param question: The original statement for which a similar but different statement is desired.
    :type question: str
    :return: The generated close-to statement.
    :rtype: str
    """
    prompt = (
        f"Please provide a similar but different statement for embeddings: {question}"
    )
    models = [
        m
        for m in palm.list_models()
        if "generateText" in m.supported_generation_methods
    ]
    model = models[0].name

    completion = palm.generate_text(
        model=model,
        prompt=prompt,
        temperature=1,
        # The maximum length of the response
        max_output_tokens=800,
        candidate_count=1,
    )

    return completion


def generate_far_from(question: str) -> str:
    """
    Generates a text completion based on a given question.

    Args:
        question (str): The question to provide a dissimilar statement for.

    Returns:
        str: The generated text completion.
    """
    prompt = f"Please provide a dissimilar statement for embeddings: {question}"

    models = [
        m
        for m in palm.list_models()
        if "generateText" in m.supported_generation_methods
    ]
    model = models[0].name

    completion = palm.generate_text(
        model=model,
        prompt=prompt,
        temperature=1,
        max_output_tokens=800,
        candidate_count=1,
    )

    return completion


def filter_candidates(
    question: str, candidates: List[Dict[str, str]]
) -> List[Dict[str, str]]:
    """
    Filter candidates based on their similarity to a given question.

    Args:
        question (str): The question to filter candidates for.
        candidates (List[Dict[str, str]]): The list of candidate dictionaries.

    Returns:
        List[Dict[str, str]]: The filtered list of candidate dictionaries.
    """
    # Generate close-to and far-from statements
    close_to = generate_close_to(question)
    far_from = generate_far_from(question)

    # Create embeddings for the question and candidates
    question_embed = palm_embed.create_embedding(
        x=question,
        close_to_x=close_to.result,
        different_from_x=far_from.result,
        model="models/embedding-gecko-001",
    )
    candidate_embeds = []
    for candidate in candidates:
        candidate_close_to = generate_close_to(candidate["output"])
        candidate_far_from = generate_far_from(candidate["output"])
        candidate_embed = palm_embed.create_embedding(
            x=candidate["output"],
            close_to_x=candidate_close_to.result,
            different_from_x=candidate_far_from.result,
            model="models/embedding-gecko-001",
        )
        candidate_embeds.append(candidate_embed)

    # Filter candidates that are more similar than different
    filtered_candidates = []
    for i, embed in enumerate(candidate_embeds):
        similar = abs(question_embed[0] - embed[0])
        different = abs(question_embed[1] - embed[1])
        if similar > different:
            continue
        filtered_candidates.append(candidates[i])

    return filtered_candidates
